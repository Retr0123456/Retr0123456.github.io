<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>测试博客.md</title>
    <link href="/2022/11/15/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2-md/"/>
    <url>/2022/11/15/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2-md/</url>
    
    <content type="html"><![CDATA[<h3 id="第-3-章-Lambda表达式"><a href="#第-3-章-Lambda表达式" class="headerlink" title="第 3 章 Lambda表达式"></a>第 3 章 Lambda表达式</h3><h4 id="3-1-认识Lambda"><a href="#3-1-认识Lambda" class="headerlink" title="3.1 认识Lambda"></a>3.1 认识Lambda</h4><blockquote><p>理论上来说，你在Java 8之前做不了的事情， Lambda也做不了  </p><p>Lambda表达式  &#x3D; 匿名函数,使代码 简洁 清晰</p><p>语法: (parameters)-&gt; expression 或者  (parameters)-&gt; {expression}</p><ol><li>只有一条执行语句,可以省略return 和 {}</li><li>只有一个参数可以省略()  没有参数不能省略()</li></ol></blockquote><h4 id="3-2-函数式接口"><a href="#3-2-函数式接口" class="headerlink" title="3.2 函数式接口"></a>3.2 函数式接口</h4><blockquote><ol><li><p>函数式接口就是只定义一个抽象方法的接口  (可以有很多默认方法)</p></li><li><p>Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，</p></li></ol><p>并把整个表达式作为函数式接口的实例    (匿名内部类也可以做到)</p><ol start="3"><li>函数式接口的抽象方法的签名(<strong>返回值类型,参数个数和类型要一致</strong>)基本上就是Lambda表达式的签名。我们将这种抽象方法叫作<strong>函数描述符</strong></li></ol></blockquote><h4 id="3-3-自定义函数式接口"><a href="#3-3-自定义函数式接口" class="headerlink" title="3.3 自定义函数式接口"></a>3.3 自定义函数式接口</h4><blockquote><ol><li><p>参数行为化(先写出需要的lambda表达式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> processFile(br -&gt;<br>        br.readLine() + br.readLine());<br></code></pre></td></tr></table></figure></li><li><p>根据签名编写接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BufferedReaderProcessor</span> &#123;<br>    String <span class="hljs-title function_">process</span><span class="hljs-params">(BufferedReader br)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行一个行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">processFile</span><span class="hljs-params">(BufferedReaderProcessor p)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span><br>                 <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;data.txt&quot;</span>))) &#123;<br>        <span class="hljs-keyword">return</span> p.process(bufferedReader);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>传递一个Lambda</p></li></ol></blockquote><h4 id="3-4-一些已经定义好的函数式接口"><a href="#3-4-一些已经定义好的函数式接口" class="headerlink" title="3.4 一些已经定义好的函数式接口"></a>3.4 一些已经定义好的函数式接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 接收一个参数,返回一个Boolean值</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt;&#123;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br>&#125;<br><span class="hljs-comment">// 接收一个参数,没有返回值</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt;&#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span>;<br>&#125;<br><span class="hljs-comment">// 接收一个参数,返回一个对象</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Function</span>&lt;T, R&gt;&#123;<br>R <span class="hljs-title function_">apply</span><span class="hljs-params">(T t)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有一些原始类型特化,比如 <strong>IntFunction</strong> 表示返回&#x2F;接收int类型 可以避免装箱带来的消耗</p><p><strong>注意事项</strong></p><ol><li><p>请注意，任何函数式接口都不允许抛出受检异常（ checked exception）  </p><p><strong>方案</strong>: 定义一个自己的函数式接口，并声明受检异常，或者把Lambda包在一个try&#x2F;catch块中。</p></li></ol><h4 id="3-5-类型检查"><a href="#3-5-类型检查" class="headerlink" title="3.5 类型检查"></a>3.5 类型检查</h4><ol><li><p>流程基本就是检查 参数类型,个数 和 返回值类型<br>如果Lambda表达式抛出一个异常，那么抽象方法所声明的throws语句也必须与之匹配<br>所以,一个Lambda表达式完全可以对应多个函数接口</p></li><li><p>特殊的void兼容规则<br>如果一个Lambda的主体是一个语句表达式， 它就和一个返回void的函数描述符兼容  </p></li><li><p>Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。 它们被称作 <strong>捕获Lambda</strong>  </p><blockquote><p>限制: Lambda表达式引用的局部变量必须是最终的（ final）或事实上最终的  </p><p>原因: </p><ol><li>实例变量在堆,局部变量在栈.假如Lambda在另一个线程访问,可能访问的是副本,就会和初始值不同</li><li>这一限制不鼓励你使用改变外部变量的典型命令式编程模式</li></ol></blockquote></li></ol><h4 id="3-6-方法引用"><a href="#3-6-方法引用" class="headerlink" title="3.6 方法引用"></a>3.6 方法引用</h4><p>方法引用就是Lambda表达式 的快捷写法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">lambda表达式等价的 方法引用<br>(Apple a) -&gt; a.getWeight() Apple::getWeight<br>() -&gt; Thread.currentThread().dumpStack() Thread.currentThread()::dumpStack<br>(str, i) -&gt; str.substring(i) String::substring<br>(String s) -&gt; System.out.println(s) System.out::println<br></code></pre></td></tr></table></figure><p>三种方法引用:</p><ol><li>指向静态方法的方法引用  Integer::parseInt  </li><li>指向任意类型实例方法的方法引用  String::length  </li><li>指向现有对象的实例方法的方法引用</li></ol><p>构造函数引用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Supplier&lt;Apple&gt; c1 = Apple::<span class="hljs-keyword">new</span>;<br></code></pre></td></tr></table></figure><h4 id="3-8-复合-Lambda-表达式的有用方法"><a href="#3-8-复合-Lambda-表达式的有用方法" class="headerlink" title="3.8 复合 Lambda 表达式的有用方法"></a>3.8 复合 Lambda 表达式的有用方法</h4><ol><li>比较器复合 Comparator  下有 reversed() &#x2F; thenComparing()</li><li>谓词复合  Predicate下    negate  and和or</li><li>函数复合 Function下    f.andThen(g)  等于g(f(x))    f.compose(g)  等于 f(g(x))</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Usage</title>
    <link href="/2022/11/15/HelloWorld/"/>
    <url>/2022/11/15/HelloWorld/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
